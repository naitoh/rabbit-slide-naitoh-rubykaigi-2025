= Improvement of REXML and speed up using StringScanner

: author
   NAITOH Jun
: institution
   MedPeer, Inc.
: content-source
   RubyKaigi 2025
: date
   2025-04-17
: theme
   .


: start-time
   2025-04-17T11:50:00+09:00
: end-time
   2025-04-17T12:20:00+09:00

== Slide properties

: enable-title-on-image
   false

= NAITOH Jun

  * @naitoh (GitHub and X(Twitter))\n
    (('note:GitHub ã¨ X(Twitter) ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ'))
  * A new maintainer of the (({rexml})) library\n
    (('note:(({rexml}))ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã®æ–°ãƒ¡ãƒ³ãƒ†ãƒŠãƒ¼ ğŸ†•'))
  * ((<Red Data Tools|URL:https://red-data-tools.github.io/>)) project member\n
    (('note:Red Data Toolsãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ãƒ³ãƒãƒ¼'))
  * ((<redmine.tokyo|URL:https://redmine.tokyo/>)) stuff\n
    (('note:redmine.tokyo å‹‰å¼·ä¼šã®ã‚¹ã‚¿ãƒƒãƒ•'))
  * Working at MedPeer, Inc.\n
    (('note:MedPeerã§åƒã„ã¦ã„ã‚‹'))

= (('note:MedPeer'))

  # img
  # src = images/medpeer_mission.png
  # relative_height = 70

== Slide properties

: enable-title-on-image
   false


= (('note:ã€€'))

  # img
  # src = images/medpeer.png
  # relative_height = 100

== Slide properties

: enable-title-on-image
   false

= rexml in Ruby 3.4 (1)\n(('note:Ruby 3.4ã® rexmlï¼ˆ1ï¼‰'))

  * Faster XML parsing\n(('note:XMLãƒ‘ãƒ¼ã‚¹ã®é«˜é€ŸåŒ–'))
    * It is up to ((*50%*)) faster between\n
      rexml 3.2.6(attached to Ruby 3.3.0) and\n
      rexml 3.4.0(attached to Ruby 3.4.0). \n
      (('note:rexml 3.2.6(Ruby 3.3.0æ·»ä»˜)ã¨rexml 3.4.0(Ruby 3.4.0æ·»ä»˜)ã®é–“ã§ã€((*æœ€å¤§50%*))é€Ÿããªã£ãŸã€‚'))

= Benchmark target file

    <?xml version="1.0"?>
    <root>
      <child id0="0" id1="0" />
       :
      <child id0="4999" id1="4999" />
    </root>

(('tag:center'))
Parsing XML with 5000 child nodes.\n(('note:5000å€‹ã®å­ãƒãƒ¼ãƒ‰ã‚’æŒã¤XMLã‚’ãƒ‘ãƒ¼ã‚¹ã™ã‚‹'))


= Ruby 3.4 YJIT disable(('note:ã€€YJIT ç„¡åŠ¹'))

    # img
    # src = images/svg_340_jit_disable.svg
    # relative_height = 60

  # RT

  (('tag:small'))parser, (('tag:small'))3.2.6, (('tag:small'))3.4.0, (('tag:small'))Faster?

  (('tag:center'))(('tag:small'))dom, (('tag:small'))(('tag:center'))18.19 i/s, (('tag:small'))(('tag:center'))18.84 i/s, (('tag:small'))(('tag:center'))1.03x
  (('tag:center'))(('tag:small'))sax2, (('tag:small'))(('tag:center'))25.82 i/s, (('tag:small'))(('tag:center'))28.59 i/s, (('tag:small'))(('tag:center'))1.11x
  (('tag:center'))(('tag:small'))pull, (('tag:small'))(('tag:center'))29.94 i/s, (('tag:small'))(('tag:center'))33.08 i/s, (('tag:small'))(('tag:center'))1.10x
  (('tag:center'))(('tag:small'))stream, (('tag:small'))(('tag:center'))28.11 i/s, (('tag:small'))(('tag:center'))32.62 i/s, (('tag:small'))(('tag:center'))1.16x

= Ruby 3.4 YJIT enable(('note:ã€€YJIT æœ‰åŠ¹'))

    # img
    # src = images/svg_340_jit_enable.svg
    # relative_height = 60

  # RT

  (('tag:small'))parser, (('tag:small'))3.2.6, (('tag:small'))3.4.0, (('tag:small'))Faster?

  (('tag:center'))(('tag:small'))dom, (('tag:small'))(('tag:center'))25.90 i/s, (('tag:small'))(('tag:center'))31.58 i/s, (('tag:small'))(('tag:center'))1.22x
  (('tag:center'))(('tag:small'))sax2, (('tag:small'))(('tag:center'))36.57 i/s, (('tag:small'))(('tag:center'))50.67 i/s, (('tag:small'))(('tag:center'))1.39x
  (('tag:center'))(('tag:small'))pull, (('tag:small'))(('tag:center'))42.71 i/s, (('tag:small'))(('tag:center'))59.88 i/s, (('tag:small'))(('tag:center'))1.40x
  (('tag:center'))(('tag:small'))stream, (('tag:small'))(('tag:center'))39.02 i/s, (('tag:small'))(('tag:center'))57.25 i/s, (('tag:small'))(('tag:center'))((*1.47x*))

= rexml in Ruby 3.4 (2)\n(('note:Ruby 3.4ã® rexmlï¼ˆ2ï¼‰'))

  * Faster XML parsing\n(('note:XMLãƒ‘ãƒ¼ã‚¹ã®é«˜é€ŸåŒ–'))
    * It is up to ((*60%*)) faster between\n
      rexml 3.2.6(attached to Ruby 3.3.0) and rexml 3.4.1. \n
      (('note:rexml 3.2.6(Ruby 3.3.0æ·»ä»˜)ã¨rexml 3.4.1ã®é–“ã§ã€((*æœ€å¤§60%*))é€Ÿããªã£ãŸ'))

= Ruby 3.4 YJIT disable(('note:ã€€YJIT ç„¡åŠ¹'))

    # img
    # src = images/svg_341_jit_disable.svg
    # relative_height = 60

  # RT

  (('tag:small'))parser, (('tag:small'))3.2.6, (('tag:small'))3.4.0, (('tag:small'))3.4.1, (('tag:small'))Faster?

  (('tag:center'))(('tag:small'))dom, (('tag:small'))(('tag:center'))18.19 i/s, (('tag:small'))(('tag:center'))18.84 i/s, (('tag:small'))(('tag:center'))19.47 i/s, (('tag:small'))(('tag:center'))1.07x
  (('tag:center'))(('tag:small'))sax2, (('tag:small'))(('tag:center'))25.82 i/s, (('tag:small'))(('tag:center'))28.59 i/s, (('tag:small'))(('tag:center'))30.21 i/s, (('tag:small'))(('tag:center'))1.16x
  (('tag:center'))(('tag:small'))pull, (('tag:small'))(('tag:center'))29.94 i/s, (('tag:small'))(('tag:center'))33.08 i/s, (('tag:small'))(('tag:center'))34.37 i/s, (('tag:small'))(('tag:center'))1.14x
  (('tag:center'))(('tag:small'))stream, (('tag:small'))(('tag:center'))28.11 i/s, (('tag:small'))(('tag:center'))32.62 i/s, (('tag:small'))(('tag:center'))34.25 i/s, (('tag:small'))(('tag:center'))1.21x

= Ruby 3.4 YJIT enable(('note:ã€€YJIT æœ‰åŠ¹'))

    # img
    # src = images/svg_341_jit_enable.svg
    # relative_height = 60

  # RT

  (('tag:small'))parser, (('tag:small'))3.2.6, (('tag:small'))3.4.0, (('tag:small'))3.4.1, (('tag:small'))Faster?

  (('tag:center'))(('tag:small'))dom, (('tag:small'))(('tag:center'))25.90 i/s, (('tag:small'))(('tag:center'))31.58 i/s, (('tag:small'))(('tag:center'))33.93 i/s, (('tag:small'))(('tag:center'))1.31x
  (('tag:center'))(('tag:small'))sax2, (('tag:small'))(('tag:center'))36.57 i/s, (('tag:small'))(('tag:center'))50.67 i/s, (('tag:small'))(('tag:center'))53.18 i/s, (('tag:small'))(('tag:center'))1.45x
  (('tag:center'))(('tag:small'))pull, (('tag:small'))(('tag:center'))42.71 i/s, (('tag:small'))(('tag:center'))59.88 i/s, (('tag:small'))(('tag:center'))65.89 i/s, (('tag:small'))(('tag:center'))1.54x
  (('tag:center'))(('tag:small'))stream, (('tag:small'))(('tag:center'))39.02 i/s, (('tag:small'))(('tag:center'))57.25 i/s, (('tag:small'))(('tag:center'))61.87 i/s, (('tag:small'))(('tag:center'))((*1.58x*))

= Ruby 3.4 rexml 3.4.1

  # img
  # src = images/svg_341.svg
  # relative_height = 80

(('tag:center'))
Up to ((*60%*)) faster.\n
(('note:((*æœ€å¤§60ï¼…*))é«˜é€ŸåŒ–'))

= RubyKaigi 2024 LT

  # img
  # src = images/RubyKaigi2024LT.png
  # relative_height = 60

* Up to 60% faster since rexml 3.2.6.\n
  (('note:rexml 3.2.6ã‹ã‚‰æœ€å¤§((*60%*))é€Ÿããªã£ãŸã€‚'))
(('tag:center'))(('wait'))ğŸ¤”

= The release version 3.2.7 was slowing down.\n(('note:ãƒªãƒªãƒ¼ã‚¹ç‰ˆã®3.2.7ãŒé…ããªã£ã¦ã„ãŸã€‚'))

      # img
      # src = images/rexml_x_1797256482272235856.png
      # relative_height = 100

== Slide properties

: enable-title-on-image
   false

= Ruby 3.4 rexml 3.2.7

  # img
  # src = images/svg_327.svg
  # relative_height = 80

(('tag:center'))
It was slow in rexml 3.2.7.\n
(('note:rexml 3.2.7 ã§é…ããªã£ã¦ã„ãŸ'))


= Parsing process was slowing down to deal with CVE.\n(('note:CVEã«å¯¾å‡¦ã™ã‚‹ãŸã‚ãƒ‘ãƒ¼ã‚¹å‡¦ç†ãŒé…ããªã£ã¦ã„ãŸ'))

  # img
  # src = images/CVE-2024-35176.png
  # relative_height = 80

(('tag:center'))
(('tag:small'))
((<CVE-2024-35176: DoS vulnerability in REXML|URL:https://www.ruby-lang.org/en/news/2024/05/16/dos-rexml-cve-2024-35176/>))



= Make REXML ((*Fast Again*)).\n(('note:REXML ã‚’((*å†ã³é«˜é€ŸåŒ–*))ã™ã‚‹'))

= What's REXML\n(('note:REXML ã¨ã¯ï¼Ÿ'))

  * REXML is a standard XML library (Bundled Gem) for Ruby implemented in Pure Ruby.\n
    (('note:REXMLã¯Pure Rubyã§å®Ÿè£…ã•ã‚ŒãŸRubyç”¨ã®æ¨™æº–XMLãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆBundled Gemï¼‰'))

= What's XML?\n(('note:XML ã¨ã¯ï¼Ÿ'))

    # rouge xml

    <?xml version="1.0"?>
    <svg xmlns="http://www.w3.org/2000/svg">
      <rect x="0" y="0" width="100" height="60" fill="#ddd" />
      <polygon points="50 10, 70 30, 50 50, 30 30" fill="#99f" />
    </svg>

  * Describe using tags like HTML.\n
    (('note:HTML ã®æ§˜ã«ã‚¿ã‚°ã‚’ç”¨ã„ã¦è¨˜è¿°ã™ã‚‹'))
  * Highly scalable data exchange format.\n
    (('note:æ‹¡å¼µæ€§ã®é«˜ã„ãƒ‡ãƒ¼ã‚¿äº¤æ›ç”¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ'))

= XML-based format example\n(('note:XMLãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆä¾‹'))

  * SVG, DOCX, XLSX, MathML, PubMed-XML, CIM-XML, etc.\n
    (('note:SVG, DOCX, XLSXã€MathMLã€PubMed XML, CIM-XML, ..'))
  * Complex expressions are possible.\n
    (('note:è¤‡é›‘ãªè¡¨ç¾ãŒå¯èƒ½'))

= XML character encoding.\n(('note:XML ã® æ–‡å­—ã‚³ãƒ¼ãƒ‰'))

  * XML supports UTF-8 and UTF-16 (required). \n
    (('note:XML ã¯ UTF-8 ã¨ UTF-16 ã‚’ã‚µãƒãƒ¼ãƒˆ(å¿…é ˆ)'))
  * Other character encoding can be used by declaring XML encoding (optional).\n
    (('note:XMLã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å®£è¨€ã™ã‚‹ã“ã¨ã§ã€ä»–ã®æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ç”¨å¯èƒ½(ã‚ªãƒ—ã‚·ãƒ§ãƒ³)'))

= How REXML processes XML.(1)\n(('note:REXML ã® XMLå‡¦ç†æ–¹æ³•(1)'))

  * REXML supports UTF-8 and UTF-16. \n
    (('note:REXML ã¯ UTF-8 ã¨ UTF-16 ã‚’ã‚µãƒãƒ¼ãƒˆ'))
  * Reads and parses XML files by tags.\n
    (('note:XMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¿ã‚°å˜ä½ã§èª­ã¿è¾¼ã¿ã€ãƒ‘ãƒ¼ã‚¹å‡¦ç†ã‚’è¡Œã†'))

= How REXML processes XML.(2)\n(('note:REXML ã® XMLå‡¦ç†æ–¹æ³•(2)'))

  * For non-UTF-8 encoding, convert to UTF-8 when reading.\n
    (('note:UTF-8 ä»¥å¤–ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å ´åˆã¯ã€èª­ã¿è¾¼ã¿æ™‚ã«UTF-8 ã«å¤‰æ›'))
  * Other encoding can basically be used if Ruby supports it.\n
    (('note:RubyãŒã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚Œã°ä»–ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚‚åŸºæœ¬çš„ã«ä½¿ç”¨å¯èƒ½'))

= About REXML's Parser\n(('note:REXMLã®ãƒ‘ãƒ¼ã‚µãƒ¼ã«ã¤ã„ã¦'))

  * REXML has a DOM/SAX2/Pull/Stream parser.\n
    (('note:REXML ã¯DOM/SAX2/Pull/Stream ã®ãƒ‘ãƒ¼ã‚µãƒ¼ãŒã‚ã‚‹'))

= Types of REXML parsers\n(('note:REXMLã®ãƒ‘ãƒ¼ã‚µãƒ¼ã®ç¨®é¡'))

  * Tree API (('note:ãƒ„ãƒªãƒ¼API'))
    * DOM(Document Object Model) parser
  * Streaming API (('note:ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°API'))
    * Callback type(passive) (('note:ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å½¢å¼(å—å‹•çš„)'))
      * SAX2 (Simple API for XML) parser
      * Stream parser
    * Pull type(active) (('note:Pullå½¢å¼(èƒ½å‹•çš„)'))
      * Pull parser

= Features of DOM parser.\n(('note:DOMãƒ‘ãƒ¼ã‚µãƒ¼ã®ç‰¹å¾´'))

  * DOM-style XML parser.\n
    (('note:DOM ã‚¹ã‚¿ã‚¤ãƒ«ã® XML ãƒ‘ãƒ¼ã‚µ'))
  * Treat XML as a tree structure.\n
    (('note:XMLã‚’æœ¨æ§‹é€ ã¨ã—ã¦æ‰±ã†'))
    * Easy to use as any node can be accessed.\n
      (('note:ä»»æ„ã®ãƒãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã®ã§ä½¿ã„ã‚„ã™ã„'))
  * Keep parsing results in memory.\n
    (('note:ãƒ‘ãƒ¼ã‚¹å‡¦ç†çµæœã‚’ãƒ¡ãƒ¢ãƒªä¸Šã«ä¿æŒã™ã‚‹'))
    * Large XML is memory inefficient and slow..\n
      (('note:å¤§ããªXMLã§ã¯ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãŒæ‚ªãé…ã„'))

= Features of SAX2 parser.(1)\n(('note:SAX2ãƒ‘ãƒ¼ã‚µãƒ¼ã®ç‰¹å¾´(1)'))

  * Stream-style parser with API equivalent to SAX2.\n
    (('note:SAX2 ã¨åŒç­‰ã® API ã‚’æŒã¤ã‚¹ãƒˆãƒªãƒ¼ãƒ å½¢å¼ã®ãƒ‘ãƒ¼ã‚µ '))
    * Sequential processing from the beginning of the file, line by line.\n
      (('note:ãƒ•ã‚¡ã‚¤ãƒ«å…ˆé ­ã‹ã‚‰ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ã«1è¡Œå˜ä½ã”ã¨ã«å‡¦ç†'))
    * By registering an event listener, callbacks are processed on an event-by-event basis.\n
      (('note:ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠã‚’ç™»éŒ²ã™ã‚‹ã“ã¨ã§ã‚¤ãƒ™ãƒ³ãƒˆå˜ä½ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†'))

= Features of SAX2 parser.(2)\n(('note:SAX2ãƒ‘ãƒ¼ã‚µãƒ¼ã®ç‰¹å¾´(2)'))
  * Not keep parsing results in memory.\n
    (('note:ãƒ‘ãƒ¼ã‚¹å‡¦ç†çµæœã‚’ãƒ¡ãƒ¢ãƒªä¸Šã«ä¿æŒã—ãªã„'))
  * Memory efficient, fast even with large XML.\n
    (('note:ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ã«å„ªã‚Œã€å¤§ããªXMLã§ã‚‚é«˜é€Ÿ'))
  * Not easy to use, because access to arbitrary nodes is not possible.\n
    (('note:ä»»æ„ã®ãƒãƒ¼ãƒ‰ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ã§ããªã„ã®ã§ã€ä½¿ã„å‹æ‰‹ã¯æ‚ªã„'))

= Features of Stream parser.\n(('note:Streamãƒ‘ãƒ¼ã‚µãƒ¼ã®ç‰¹å¾´'))
  * Basically the same as SAX2 parser.\n
    (('note:åŸºæœ¬çš„ã«ã¯ SAX2 ãƒ‘ãƒ¼ã‚µãƒ¼ã¨åŒã˜'))
    * Stream parsers are lightweight and fast because of their limited functionality.\n
      (('note:Streamãƒ‘ãƒ¼ã‚µãƒ¼ã¯ æ©Ÿèƒ½ãŒé™å®šçš„ãªã®ã§è»½é‡ã®ãŸã‚é€Ÿã„'))

= Features of Pull parser.\n(('note:Pullãƒ‘ãƒ¼ã‚µãƒ¼ã®ç‰¹å¾´'))
  * Stream-style parser, processing one line at a time.\n
    (('note:ã‚¹ãƒˆãƒªãƒ¼ãƒ å½¢å¼ã®ãƒ‘ãƒ¼ã‚µã§ã€1è¡Œå˜ä½ã«å‡¦ç†ã™ã‚‹'))
  * Pull parser reads and processes each event by itself.\n
    (('note:Pullãƒ‘ãƒ¼ã‚µãƒ¼ã¯å„ã‚¤ãƒ™ãƒ³ãƒˆã‚’è‡ªåˆ†ã§èª­ã¿è¾¼ã‚“ã§å‡¦ç†ã™ã‚‹'))



= Motivation(1)\n(('note:å‹•æ©Ÿ(1)'))

  * I am the author of the PDF export library ((<RBPDF gem|URL:https://github.com/naitoh/rbpdf/>)).\n
    (('note:ç§ã¯ PDFå‡ºåŠ›ãƒ©ã‚¤ãƒ–ãƒ©ãƒªRBPDF gemã®ä½œè€…'))
    * RBPDF is used by ((*Redmine*))'s PDF output feature.\n
      (('note:RBPDF ã¯ ((*Redmine*)) ã®PDFå‡ºåŠ›æ©Ÿèƒ½ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹'))
      * I would like to support PDF output of SVG images in RBPDF using REXML, which is easy to install.\n
        (('note:ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã®å®¹æ˜“ãªREXMLã‚’ç”¨ã„ã¦RBPDFã§SVGç”»åƒã®PDFå‡ºåŠ›ã‚’ã‚µãƒãƒ¼ãƒˆã—ãŸã„'))

= Motivation(2)\n(('note:å‹•æ©Ÿ(2)'))

  * REXML performance is slower than C extension gem.\n
    (('note:REXMLã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒCæ‹¡å¼µgemã‚ˆã‚Šé…ã„'))
  * I would like to improve REXML performance.\n
    (('note:REXMLã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’æ”¹å–„ã—ãŸã„'))


= Improvements\n(('note:æ”¹å–„ç‚¹'))

  * Up to 50% speedup between rexml 3.2.6 (Ruby 3.3.0 attached) and rexml 3.4.0 (Ruby 3.4.0 attached).\n
    (('note:rexml 3.2.6(Ruby 3.3.0 æ·»ä»˜) ã‹ã‚‰ã€rexml 3.4.0(Ruby 3.4.0 æ·»ä»˜) ã®é–“ã§æœ€å¤§50%ã®é«˜é€ŸåŒ–ã‚’å®Ÿç¾'))
  * It is up to ((*60%*)) faster between rexml 3.2.6 and rexml 3.4.1.\n
    (('note:rexml 3.2.6 ã‹ã‚‰ rexml 3.4.1 ã®é–“ã§((*æœ€å¤§60%*))ã®é«˜é€ŸåŒ–ã‚’å®Ÿç¾'))

= How?\n(('note:ã©ã†ã‚„ã£ã¦ï¼Ÿ'))

  # img
  # src = images/rubykaigi-2019-p35-p78.png
  # relative_height = 60

(('tag:center'))
(('tag:small'))
"Improving CSV Processing with Ruby 2.6"\n
at RubyKaigi 2019\n
(('note:((<URL:https://slide.rabbit-shocker.org/authors/kou/rubykaigi-2019/>))'))

= What is StringScanner?(1)\n(('note:StringScanner ã¨ã¯ï¼Ÿ(1)'))

  * StringScanner is a sequential string scanner.\n
    (('note:StringScanner ã¯é€æ¬¡çš„ãªæ–‡å­—åˆ—ã‚¹ã‚­ãƒ£ãƒŠ'))
    * Sequential String Scanning\n(('note:æ–‡å­—åˆ—ã®é€æ¬¡ã‚¹ã‚­ãƒ£ãƒ³'))
    * Regular Expression Matching\n(('note:æ­£è¦è¡¨ç¾ãƒãƒƒãƒãƒ³ã‚°'))
    * State Management\n(('note:çŠ¶æ…‹ç®¡ç†'))


= StringScanner Features(1)\n(('note:StringScanner ã®ç‰¹å¾´(1)'))

  * Sequential String Scanning\n(('note:æ–‡å­—åˆ—ã®é€æ¬¡ã‚¹ã‚­ãƒ£ãƒ³'))
      * It processes a string from the beginning, moving forward as it matches patterns.\n
        (('note:æ–‡å­—åˆ—ã®å…ˆé ­ã‹ã‚‰é †ç•ªã«è§£æã—ãªãŒã‚‰å…ˆã«é€²ã‚€'))
  * Regular Expression Matching\n(('note:æ­£è¦è¡¨ç¾ãƒãƒƒãƒãƒ³ã‚°'))
  * State Management\n(('note:çŠ¶æ…‹ç®¡ç†'))

= StringScanner Features(2)\n(('note:StringScanner ã®ç‰¹å¾´(2)'))

  * Sequential String Scanning\n(('note:æ–‡å­—åˆ—ã®é€æ¬¡ã‚¹ã‚­ãƒ£ãƒ³'))
  * Regular Expression Matching\n(('note:æ­£è¦è¡¨ç¾ãƒãƒƒãƒãƒ³ã‚°'))
      * Use scan(), scan_until(), etc. to look for specific patterns.\n
        (('note:scan(), scan_until() ãªã©ã‚’ä½¿ã£ã¦ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ã™ã€‚'))
  * State Management\n(('note:çŠ¶æ…‹ç®¡ç†'))

= StringScanner Features(3)\n(('note:StringScanner ã®ç‰¹å¾´(3)'))

  * Sequential String Scanning\n(('note:æ–‡å­—åˆ—ã®é€æ¬¡ã‚¹ã‚­ãƒ£ãƒ³'))
  * Regular Expression Matching\n(('note:æ­£è¦è¡¨ç¾ãƒãƒƒãƒãƒ³ã‚°'))
  * State Management\n(('note:çŠ¶æ…‹ç®¡ç†'))
      * pos (current position) and rest (rest of string) to see how far you have parsed.\n
        (('note:pos (ç¾åœ¨ã®ä½ç½®) ã‚„ rest (æ®‹ã‚Šã®æ–‡å­—åˆ—) ã§ã€ã©ã“ã¾ã§è§£æã—ãŸã‹ã‚’æŠŠæ¡ã§ãã‚‹'))

= What is StringScanner?(2)\n(('note:StringScanner ã¨ã¯ï¼Ÿ(2)'))
  * Available since Ruby 1.8 and default gem since Ruby 2.5.\n
    (('note:Ruby 1.8 ã‹ã‚‰ä½¿ç”¨å¯èƒ½ã§ Ruby 2.5 ä»¥é™ã§ default gem ã«ãªã£ã¦ã„ã‚‹'))
  * Uses Ruby's regular expression engine (Onigmo).\n
    (('note:Rubyã®æ­£è¦è¡¨ç¾ã‚¨ãƒ³ã‚¸ãƒ³(Onigmo)ã‚’ä½¿ã£ã¦ã„ã‚‹'))
    * ReDoS countermeasure implemented in Ruby 3.2 is also effective.ğŸ‘\n
      (('note:Ruby 3.2ã§å®Ÿè£…ã•ã‚ŒãŸReDoSå¯¾ç­–ã‚‚æœ‰åŠ¹'))

= StringScanner is fast.(1)\n(('note:StringScanner ã¯é€Ÿã„(1)'))

    # rouge ruby

    /\A\w+/.match('test string') #=> 'test'
    s = StringScanner.new('test string')
    s.check(/\w+/) #=> 'test'
    s.check('test') #=> 'test'

  # RT

  (('tag:center'))(('tag:small'))Regexp#match, (('tag:center'))(('tag:small')) 5.675M i/s
  (('tag:center'))(('tag:small'))StringScanner\n#check(Regexp), (('tag:center'))(('tag:small')) 8.800M i/s\n (('note:(1.55x faster)'))
  (('tag:center'))(('tag:small'))StringScanner\n#check(String), (('tag:center'))(('tag:small')) 10.27M i/s\n (('note:(1.81x faster)'))

= StringScanner is fast.(2)\n(('note:StringScanner ã¯é€Ÿã„(2)'))

    # RT

    (('tag:center'))(('tag:small'))Regexp#match, (('tag:center'))(('tag:small')) 5.675M i/s
    (('tag:center'))(('tag:small'))StringScanner\n#check(Regexp), (('tag:center'))(('tag:small')) 8.800M i/s\n (('note:(1.55x faster)'))
    (('tag:center'))(('tag:small'))StringScanner\n#check(String), (('tag:center'))(('tag:small')) 10.27M i/s\n (('note:(((*1.81x*)) faster)'))

  * StringScanner#check(String) is fast because it uses ((*memcmp()*)) for comparison.\n
    (('note:StringScanner#check(String) ã¯æ¯”è¼ƒã« ((*memcmp()*)) ã‚’ä½¿ã†ã®ã§é€Ÿã„'))

= StringScanner is fast.(3)\n(('note:StringScanner ã¯é€Ÿã„(3)'))

    # RT

    (('tag:center'))(('tag:small'))Regexp#match, (('tag:center'))(('tag:small')) 5.675M i/s
    (('tag:center'))(('tag:small'))StringScanner\n#check(Regexp), (('tag:center'))(('tag:small')) 8.800M i/s\n (('note:(1.55x faster)'))

  * Regexp#match generates and returns a MatchData Object.\n
    (('note:Regexp#match ã¯ MatchData Object ã‚’ç”Ÿæˆã—ã¦è¿”ã™'))
  * StringScanner#check copies the matched string and returns it.\n
    (('note:StringScanner#check ã¯ãƒãƒƒãƒã—ãŸæ–‡å­—åˆ—ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦è¿”ã™'))

= Without match object generation, performance is equivalent.\n(('note:ãƒãƒƒãƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆç„¡ã—ã®å ´åˆã€æ€§èƒ½ã¯åŒç­‰'))

    # RT

    (('tag:center'))(('tag:small'))Regexp#match?, (('tag:center')) 14.71M i/s
    (('tag:center'))(('tag:small'))StringScanner#match?, (('tag:center')) 14.28M i/s (('note:(1.03x slower)'))

  * Regexp#match? and StringScanner\n#match? respond with boolean.\n
    (('note:Regexp#match?ã¨StringScanner#match? ã¯boolean ã§å¿œç­”'))
    * Performance is equivalent since both are only regular expression processing.\n
      (('note:ä¸¡æ–¹ã¨ã‚‚æ­£è¦è¡¨ç¾å‡¦ç†ã®ã¿ãªã®ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¯åŒç­‰'))

= rexml in Ruby 3.4 (2)\n(('note:Ruby 3.4ã®rexmlï¼ˆ2ï¼‰'))

(('tag:small:Use StringScanner#scan'))\n
(('tag:small:instead of Regexp#match'))\n
(('tag:small:to parse XML.'))\n
(('note:XMLã®ãƒ‘ãƒ¼ã‚¹ã«Regexp#matchã®ä»£ã‚ã‚Šã«StringScanner#scanã‚’ä½¿ã†'))

= Example of Regexp class use\n(('note:Regexpã‚¯ãƒ©ã‚¹ã‚’ä½¿ã†ä¾‹'))

  * Repeat until a match is found in the regular expression.\n
    (('note:æ­£è¦è¡¨ç¾ã§ãƒãƒƒãƒã™ã‚‹ã¾ã§ç¹°ã‚Šè¿”ã™'))

  # rouge ruby

  word = (/\A<[^>]*>/um).match('<!-- foo -->') # Get Tag
  case word[0]
  when /\A<\?xml\s/u     ğŸ‘ˆ  Not Match
  when /\A<!--/u
    /<!--(.*?)-->/um.match(word[0])[0] #=> " foo "
  when /\A<!DOCTYPE\s/um

= Example of Regexp class use\n(('note:Regexpã‚¯ãƒ©ã‚¹ã‚’ä½¿ã†ä¾‹'))

  * Repeat until a match is found in the regular expression.\n
    (('note:æ­£è¦è¡¨ç¾ã§ãƒãƒƒãƒã™ã‚‹ã¾ã§ç¹°ã‚Šè¿”ã™'))

  # rouge ruby

  word = (/\A<[^>]*>/um).match('<!-- foo -->') # Get Tag
  case word[0]
  when /\A<\?xml\s/u
  when /\A<!--/u         ğŸ‘ˆ  Match
    /<!--(.*?)-->/um.match(word[0])[0] #=> " foo "
  when /\A<!DOCTYPE\s/um


= Example of StringScanner use(1)\n(('note:StringScannerã®ä½¿ç”¨ä¾‹(1)'))

  * Parses strings sequentially from the beginning.\n
    (('note:æ–‡å­—åˆ—ã®å…ˆé ­ã‹ã‚‰é †ç•ªã«è§£æã™ã‚‹'))
  * Easy to understand process.\n
    (('note:å‡¦ç†ãŒã‚ã‹ã‚Šã‚„ã™ã„'))

= Example of StringScanner use(1)\n(('note:StringScannerã®ä½¿ç”¨ä¾‹(1)'))

    # rouge ruby

    s = StringScanner.new('<!-- foo -->')
    s.pos = 0 # for Benchmark
    if s.scan("<?")     ğŸ‘ˆ  Not Match
    elsif s.scan("<!")
      if s.scan("--")
        s.scan(/(.*?)-->/um) and s[1] #=> " foo "ã€€
      elsif s.scan("DOCTYPE")

  # RT

  (('tag:center'))<,(('tag:center'))!,(('tag:center'))-,(('tag:center'))-, ,(('tag:center'))f,(('tag:center'))o,(('tag:center'))o, ,(('tag:center'))-,(('tag:center'))-,(('tag:center'))>

  â˜ï¸, , , , , , , , , , ,

= Example of StringScanner use(1)\n(('note:StringScannerã®ä½¿ç”¨ä¾‹(1)'))

    # rouge ruby

    s = StringScanner.new('<!-- foo -->')
    s.pos = 0 # for Benchmark
    if s.scan("<?")
    elsif s.scan("<!") ğŸ‘ˆ  Match
      if s.scan("--")
        s.scan(/(.*?)-->/um) and s[1] #=> " foo "ã€€
      elsif s.scan("DOCTYPE")

  # RT

  (('tag:center'))<,(('tag:center'))!,(('tag:center'))-,(('tag:center'))-, ,(('tag:center'))f,(('tag:center'))o,(('tag:center'))o, ,(('tag:center'))-,(('tag:center'))-,(('tag:center'))>

   â–¶ï¸,â–¶ï¸,â˜ï¸, , , , , , , , ,

= Example of StringScanner use(1)\n(('note:StringScannerã®ä½¿ç”¨ä¾‹(1)'))

    # rouge ruby

    s = StringScanner.new('<!-- foo -->')
    s.pos = 0 # for Benchmark
    if s.scan("<?")
    elsif s.scan("<!") ğŸ‘ˆ
      if s.scan("--")  ğŸ‘ˆ  Match
        s.scan(/(.*?)-->/um) and s[1] #=> " foo "ã€€
      elsif s.scan("DOCTYPE")

  # RT

  (('tag:center'))<,(('tag:center'))!,(('tag:center'))-,(('tag:center'))-, ,(('tag:center'))f,(('tag:center'))o,(('tag:center'))o, ,(('tag:center'))-,(('tag:center'))-,(('tag:center'))>

   , ,â–¶ï¸,â–¶ï¸,â˜ï¸, , , , , , ,

= Example of StringScanner use(1)\n(('note:StringScannerã®ä½¿ç”¨ä¾‹(1)'))

    # rouge ruby

    s = StringScanner.new('<!-- foo -->')
    s.pos = 0 # for Benchmark
    if s.scan("<?")
    elsif s.scan("<!") ğŸ‘ˆ
      if s.scan("--")  ğŸ‘ˆ
        s.scan(/(.*?)-->/um) and s[1] #=> " foo "ğŸ‘ˆ
      elsif s.scan("DOCTYPE")

  # RT

  (('tag:center'))<,(('tag:center'))!,(('tag:center'))-,(('tag:center'))-, ,(('tag:center'))f,(('tag:center'))o,(('tag:center'))o, ,(('tag:center'))-,(('tag:center'))-,(('tag:center'))>

   , , , ,â–¶ï¸,â–¶ï¸,â–¶ï¸,â–¶ï¸,â–¶ï¸,â–¶ï¸,â–¶ï¸,â˜ï¸

= Benchmark result\n(('note:ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯çµæœ'))

    # RT

    (('tag:center'))(('tag:small'))Regexp#match, (('tag:center')) 1.210M i/s
    (('tag:center'))(('tag:small'))StringScanner#scan, (('tag:center')) 2.225M  i/s\n (('note:(1.84x faster)'))

  * Using StringScanner is 1.8 times faster.\n
    (('note:StringScanner ã‚’ä½¿ã£ãŸæ–¹ãŒ 1.8 å€é€Ÿã„'))

= rexml in Ruby 3.4 (3)\n(('note:Ruby 3.4ã®rexmlï¼ˆ3ï¼‰'))

(('tag:center'))
(('tag:small:Use StringScanner#scan_until'))\n
(('tag:small:instead of Regexp#match'))\n
(('tag:small:to parse XML.'))\n
(('note:XMLã®ãƒ‘ãƒ¼ã‚¹ã«Regexp#matchã®ä»£ã‚ã‚Šã«StringScanner#scan_until ã‚’ä½¿ã†'))

    # rouge ruby

    s = StringScanner.new('test string')
    s.scan_until(/str/) # => "test str"

= Regexp Class

    # rouge ruby

    xml = "<![CDATA[#{'a'*n}]]>"
    md = xml.match(/\A<!\[CDATA\[(.*?)\]\]>/um)
    md[1]
    => "aaa.."

  # RT

  , (('tag:center'))(('tag:small'))n=10,(('tag:center'))(('tag:small'))n=100

  (('tag:center'))(('tag:small'))Regexp#match, (('tag:center'))(('tag:small'))2856k i/s, (('tag:center'))(('tag:small'))976k i/s

= StringScanner#check(Regexp)

      # rouge ruby

      s = StringScanner.new("<![CDATA[#{'a'*n}]]>")
      s.check(/<!\[CDATA\[(.*?)\]\]>/um) and s[1]
      => "aaa.."

    # RT

    , (('tag:center'))(('tag:small'))n=10,(('tag:center'))(('tag:small'))n=100

    (('tag:center'))(('tag:small'))Regexp#match, (('tag:center'))(('tag:small'))2856k i/s, (('tag:center'))(('tag:small'))976k i/s
    (('tag:center'))(('tag:small'))#scan\n(Regexp), (('tag:center'))(('tag:small'))4146k i/s\n (('note:(1.45x faster)')), (('tag:center'))(('tag:small'))1137k i/s\n (('note:(1.16x faster)'))

  * (('tag:small'))Using StringScanner is 1.45 times faster.\n
    (('note:StringScanner ã‚’ä½¿ã£ãŸæ–¹ãŒ 1.45 å€é€Ÿã„'))

= StringScanner#scan_until String

      # rouge ruby

      s = StringScanner.new("<![CDATA[#{'a'*n}]]>")
      s.pos = 0 and s.skip("<!") and s.skip("[CDATA[")\
      and s.scan_until("]]>").chomp!("]]>") #=>"aaa.."

    # RT

    , (('tag:center'))(('tag:small'))n=10,(('tag:center'))(('tag:small'))n=100

    (('tag:center'))(('tag:small'))Regexp#match, (('tag:center'))(('tag:small'))2856k i/s, (('tag:center'))(('tag:small'))976k i/s
    (('tag:center'))(('tag:small'))#scan\n(Regexp), (('tag:center'))(('tag:small'))4146k i/s\n (('note:(1.45x faster)')), (('tag:center'))(('tag:small'))1137k i/s\n (('note:(1.16x faster)'))
    (('tag:center'))(('tag:small'))#scan_until\n(String), (('tag:center'))(('tag:small'))4513k i/s\n (('note:(1.58x faster)')), (('tag:center'))(('tag:small'))3574k i/s\n (('note:(((*3.66x*)) faster)'))

  * (('tag:small'))Using scan_until(String) is 3.6 times faster and less degrading.
    (('note:scan_until(String) ã®æ–¹ãŒ3.6å€é€Ÿãã€åŠ£åŒ–ã—ã«ãã„'))

= rexml in Ruby 3.4 (3)\n(('note:Ruby 3.4ã®rexmlï¼ˆ3ï¼‰'))

* Using string matching\n (instead of regular expressions)\n is faster.\n
  (('note:(æ­£è¦è¡¨ç¾ã®ä»£ã‚ã‚Šã«)æ–‡å­—åˆ—ãƒãƒƒãƒã‚’ä½¿ã†ã¨ã€ã‚ˆã‚Šé«˜é€Ÿ'))
  * Even when match strings are long, performance degradation is minimized.\n
    (('note:ãƒãƒƒãƒæ–‡å­—åˆ—ãŒé•·ããªã£ã¦ã‚‚ã€æ€§èƒ½åŠ£åŒ–ã‚’æœ€å°é™ã«æŠ‘ãˆã‚‰ã‚Œã‚‹'))

= StringScanner#scan_until String

  * ((<strscan#106|URL:https://github.com/ruby/strscan/pull/106>)) Support for string matching in strscan 3.1.2(attached to Ruby 3.4.0).\n(('note:(Ruby 3.4.0æ·»ä»˜ã®)strscan 3.1.2 ã§æ–‡å­—åˆ—ãƒãƒƒãƒã«å¯¾å¿œ'))
  * StringScanner#scan_until(String) is fast because it uses ((*rb_memsearch()*)) for comparison.\n
    (('note:StringScanner#scan_until(String) ã¯æ¯”è¼ƒã« ((*rb_memsearch()*)) ã‚’ä½¿ã†ã®ã§é€Ÿã„'))

= rexml in Ruby 3.4 (4)\n(('note:Ruby 3.4ã®rexmlï¼ˆ4ï¼‰'))

(('tag:small:Suppress generation of'))\n
(('tag:small:unnecessary String Objects.'))\n
(('note:ä¸è¦ãª String Object ã®ç”Ÿæˆã‚’æŠ‘åˆ¶ã™ã‚‹'))

= Generating String Object (copying data) takes time\n(('note:æ–‡å­—åˆ— Object ã®ç”Ÿæˆ(ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ”ãƒ¼)ã«æ™‚é–“ãŒã‹ã‹ã‚‹'))

    # rouge ruby

    s = StringScanner.new(' ')
    s.check(/\s+/um) #=> " "
    s.match?(/\s+/um) #=> 1

  * No match string needed for whitespace removal.\n
    (('note:ç©ºç™½é™¤å»ã®å ´åˆã¯ãƒãƒƒãƒæ–‡å­—åˆ—ã¯ä¸è¦'))

= Benchmark result

  * Faster if no match string is needed.\n
    (('note:ãƒãƒƒãƒæ–‡å­—åˆ—ä¸è¦ãªã‚‰é€Ÿããªã‚‹'))

  # RT

  , /\s+/um

  (('tag:center'))check, (('tag:left'))6686K i/s
  (('tag:center'))match?, (('tag:left'))8925K i/s (('note:(1.33x faster)'))

= String matching is faster.(1)\n(('note:æ–‡å­—åˆ—ãƒãƒƒãƒãªã‚‰ã‚ˆã‚Šé«˜é€Ÿ(1)'))

    # rouge ruby

    s = StringScanner.new('<![CDATA[')
    if s.check(/<!/um) .. #=> "<!"
    if s.match?(/<!/um) .. #=> 2
    if s.check('<!') .. #=> "<!"
    if s.match?('<!') .. #=> 2

  * Branching process does not need match string.
    (('note: åˆ†å²å‡¦ç†ã§ã¯ãƒãƒƒãƒæ–‡å­—åˆ—ã¯ä¸è¦'))


= String matching is faster.(2)\n(('note:æ–‡å­—åˆ—ãƒãƒƒãƒãªã‚‰ã‚ˆã‚Šé«˜é€Ÿ(2)'))

  * Faster if no match string is needed.\n
    (('note:ãƒãƒƒãƒæ–‡å­—åˆ—ä¸è¦ãªã‚‰é€Ÿããªã‚‹'))
  * String matching is faster.\n
    (('note:æ–‡å­—åˆ—ãƒãƒƒãƒãªã‚‰ã‚ˆã‚Šé«˜é€Ÿ'))

  # RT

  , /<!/um, '<!'

  (('tag:center'))check, (('tag:center'))10525K i/s, (('tag:center'))14450K i/s (('note:(1.37x faster)'))
  (('tag:center'))match?, (('tag:center'))18731K i/s (('note:(1.78x faster)')), (('tag:center'))31900K i/s (('note:(3.03x faster)'))


= Avoid generating String object(1)\n(('note:æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆã‚’é¿ã‘ã‚‹(1)'))

    # rouge ruby

    s = StringScanner.new("'test'>")
    s.check(/(['"])/) #=> "'"

  * Need to determine if double or single quotes are used to get attribute values.\n
    (('note:å±æ€§å€¤ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã®åˆ¤æ–­ãŒå¿…è¦'))

= Avoid generating String object(2)\n(('note:æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆã‚’é¿ã‘ã‚‹(2)'))

    # rouge ruby

    s = StringScanner.new("'test'>")        
    case s.peek_byte
    when 34 then '"' # '"'.ord
    when 39 then "'" # "'".ord
    end #=> "'"

  * If a single byte is returned as a number, no object is created.\n
    (('note: 1ãƒã‚¤ãƒˆãªã‚‰æ•°å€¤ã§è¿”ã›ã°ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ç”Ÿæˆã•ã‚Œãªã„'))

= Benchmark result

  * Faster without object generation.\n
    (('note:ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆç„¡ã—ã§ã‚ˆã‚Šé€Ÿã'))

  # RT

  (('tag:center'))with object, (('tag:left'))10385k i/s
  (('tag:center'))without object, (('tag:left'))32000K i/s (('note:(3.08x faster)'))

= StringScanner#peek_byte

  * New methods added in strscan 3.1.2 (attached to Ruby 3.4.0)\n(('note:(Ruby 3.4.0æ·»ä»˜ã®)strscan 3.1.2 ã§è¿½åŠ ã•ã‚ŒãŸæ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰'))
  * Referring to ((<Fast Route Parsing in Rails (('tag:small:(by Aaron Patterson)'))|URL:https://www.youtube.com/watch?v=ZE6F3drGhA8>>)), REXML was also made faster using peek_byte.\n
    (('note:Fast Route Parsing in Rails ã®è©±ã‚’å‚è€ƒã«ã€REXML ã‚‚ peek_byte ã‚’ä½¿ã£ã¦é€Ÿããªã‚Šã¾ã—ãŸ'))

= rexml in Ruby 3.4 (5)\n(('note:Ruby 3.4ã®rexmlï¼ˆ5ï¼‰'))

(('tag:small:Use constants or memoization'))\n
(('tag:small:for slow processes.'))\n
(('note:é…ã„å‡¦ç†ã«ã¯å®šæ•°ã‚„ãƒ¡ãƒ¢åŒ–ã‚’ä½¿ã†'))

= Regexp.escape is slow, so use Constant.\n(('note:Regexp.escape ã¯é…ã„ã®ã§å®šæ•°åŒ–'))

    # rouge ruby

    REG = /#{Regexp.escape("'")}/
    s = StringScanner.new("test'>")
    s.check_until(REG)

  # RT

  (('tag:center'))not use Constant, (('tag:left'))1393K i/s
  (('tag:center'))use Constant, (('tag:left'))9660K i/s (('note:(6.93x faster)'))

= Encoding of the read delimiter.\n(('note: èª­ã¿å–ã‚ŠåŒºåˆ‡ã‚Šæ–‡å­—ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰'))

  * REXML reads XML with ">" as read delimiter.\n
    (('note:REXML ã¯ ">" ã‚’èª­ã¿è¾¼ã¿åŒºåˆ‡ã‚Šæ–‡å­—ã¨ã—ã¦XMLã‚’èª­ã¿è¾¼ã‚€'))
    * In UTF-16, ">" is 2 byte.\n
      (('note: UTF-16 ã®å ´åˆã€">" ã¯ 2byte'))

  # RT

  ,(('tag:center'))<,,(('tag:center'))f,,(('tag:center'))o,,(('tag:center'))o,,(('tag:center'))>

  , , , , , , , ,â˜ï¸,â˜ï¸

= Memorize the encoding result of the read delimiter.\n(('note:èª­ã¿å–ã‚ŠåŒºåˆ‡ã‚Šæ–‡å­—ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰çµæœã®ãƒ¡ãƒ¢åŒ–'))

  * One character code exists for each XML instance.\n
    (('note:XMLã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ¯ã«æ–‡å­—ã‚³ãƒ¼ãƒ‰ã¯ä¸€ã¤å­˜åœ¨'))

  # rouge ruby

  term = '>'
  @term_encord ||= term.encode('UTF-16BE')

= ((*Made*)) REXML Fast Again!\n(('note:REXML ã‚’å†ã³é«˜é€ŸåŒ–ã—ãŸï¼'))

  # img
  # src = images/svg_327.svg
  # relative_height = 100

== Slide properties

: enable-title-on-image
   false

= Other improvements.\n(('note:ä»–ã®æ”¹å–„ç‚¹'))

  * Enhanced invalid XML check.\n
    (('note:ç„¡åŠ¹XMLãƒã‚§ãƒƒã‚¯å¼·åŒ–'))
  * Unification of processing results for each REXML parser (DOM/SAX2/Pull/Stream).\n
    (('note:å„ãƒ‘ãƒ¼ã‚µãƒ¼é–“ã§ã®ãƒ‘ãƒ¼ã‚¹å‡¦ç†çµæœã®çµ±ä¸€'))

= Enhanced invalid XML check(1).\n(('note:ç„¡åŠ¹XMLãƒã‚§ãƒƒã‚¯å¼·åŒ–(1)'))

    # rouge xml

    <root1></root1>
    <root2></root2>

  * Multiple root tags.\n
    (('note:è¤‡æ•°ã®ãƒ«ãƒ¼ãƒˆã‚¿ã‚°'))

= Enhanced invalid XML check(2).\n(('note:ç„¡åŠ¹XMLãƒã‚§ãƒƒã‚¯å¼·åŒ–(2)'))

    # rouge xml

    foo
    <root></root>

  * String before the root tag.\n
    (('note:ãƒ«ãƒ¼ãƒˆã‚¿ã‚°å‰ã®æ–‡å­—åˆ—'))
    * ((<rexml#212|URL:https://github.com/ruby/rexml/issues/212>)): If the BOM is broken, it is interpreted as a string and can detect errors.\n
      (('note:BOMãŒå£Šã‚ŒãŸå ´åˆã€æ–‡å­—åˆ—ã¨è§£é‡ˆã•ã‚Œã‚‹ã®ã§ã‚¨ãƒ©ãƒ¼æ¤œå‡ºã§ãã‚‹ã€‚'))

= Enhanced invalid XML check(3).\n(('note:ç„¡åŠ¹XMLãƒã‚§ãƒƒã‚¯å¼·åŒ–(3)'))

    # rouge xml

    <root></root>
    bar

  * String after the root tag.\n
    (('note:ãƒ«ãƒ¼ãƒˆã‚¿ã‚°å¾Œã®æ–‡å­—åˆ—'))

= Enhanced invalid XML check(4).\n(('note:ç„¡åŠ¹XMLãƒã‚§ãƒƒã‚¯å¼·åŒ–(4)'))

    # rouge xml

    429 Too Many Requests

  * String with no root tag.\n
    (('note:ãƒ«ãƒ¼ãƒˆã‚¿ã‚°ãŒç„¡ã„æ–‡å­—åˆ—'))
    * If an error string is responded instead of XML, the XML parser can handle the error.\n
      (('note:XMLã§ã¯ãªãã‚¨ãƒ©ãƒ¼æ–‡å­—åˆ—ãŒå¿œç­”ã•ã‚ŒãŸå ´åˆã«ã€XMLãƒ‘ãƒ¼ã‚µãƒ¼å´ã§ã‚¨ãƒ©ãƒ¼å‡¦ç†ã§ãã‚‹ã€‚'))

= Unification of processing results for each REXML parser.(1)\n(('note:å„ãƒ‘ãƒ¼ã‚µãƒ¼é–“ã§ã®ãƒ‘ãƒ¼ã‚¹å‡¦ç†çµæœã®çµ±ä¸€(1)'))

  * REXML has a DOM/SAX2/Pull/Stream parser and there are differences in processing procedures'.\n
    (('note:REXMLã¯DOM/SAX2/Pull/Streamãƒ‘ãƒ¼ã‚µãƒ¼ãŒã‚ã‚Šå‡¦ç†æ‰‹é †ã«å·®ãŒã‚ã‚‹'))
    * There was a difference in the parsing result, so it was fixed.\n
      (('note:ãƒ‘ãƒ¼ã‚¹å‡¦ç†çµæœã«ã‚‚å·®ç•°ãŒã‚ã£ãŸã®ã§ä¿®æ­£ã—ãŸ'))

= Unification of processing results for each REXML parser.(2)\n(('note:å„ãƒ‘ãƒ¼ã‚µãƒ¼é–“ã§ã®ãƒ‘ãƒ¼ã‚¹å‡¦ç†çµæœã®çµ±ä¸€(2)'))

  * There were also differences in error handling items.\n
    (('note:ã‚¨ãƒ©ãƒ¼å‡¦ç†é …ç›®ã«ã‚‚å·®ãŒã‚ã£ãŸ'))
    * Some of the security measures were implemented only in the DOM parser.\n
      (('note:ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã®ä¸€éƒ¨ãŒDOMãƒ‘ãƒ¼ã‚µãƒ¼ã®ã¿ã®å®Ÿè£…ã ã£ãŸ'))
      * ((<CVE-2024-41946: DoS vulnerability in REXML|URL:https://www.ruby-lang.org/en/news/2024/08/01/dos-rexml-cve-2024-41946/>))
        * Fixed in REXML 3.3.3.\n
          (('note:REXML 3.3.3 ã§ä¿®æ­£æ¸ˆ'))

= Summary: Performance(1)\n(('note:ã¾ã¨ã‚:æ€§èƒ½(1)'))

  * Use StringScanner instead of Regexp class to parse XML.\n
    (('note:XMLã®ãƒ‘ãƒ¼ã‚¹ã«Regexpã‚¯ãƒ©ã‚¹ã®ä»£ã‚ã‚Šã«StringScannerã‚’ä½¿ã†'))
  * Using string matching is faster.\n
    (('note:æ–‡å­—åˆ—ãƒãƒƒãƒã‚’ä½¿ã†ã¨ã€ã‚ˆã‚Šé«˜é€Ÿ'))
    * Even when match strings are long, performance degradation is minimized.\n
      (('note:ãƒãƒƒãƒæ–‡å­—åˆ—ãŒé•·ããªã£ã¦ã‚‚ã€æ€§èƒ½åŠ£åŒ–ã‚’æœ€å°é™ã«æŠ‘ãˆã‚‰ã‚Œã‚‹'))

= Summary: Performance(2)\n(('note:ã¾ã¨ã‚:æ€§èƒ½(2)'))

  * Avoiding generation of String object is faster.\n
    (('note:æ–‡å­—åˆ— Object ã®ç”Ÿæˆã‚’é¿ã‘ã‚‹ã¨é€Ÿã„'))
  * Use constants or memoization \nfor slow processes.\n
    (('note:é…ã„å‡¦ç†ã«ã¯å®šæ•°ã‚„ãƒ¡ãƒ¢åŒ–ã‚’ä½¿ã†'))
  * After eliminating bottlenecks, \nYJIT makes it even faster.\n
    (('note:ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã‚’è§£æ¶ˆå¾Œã€YJITã§ã•ã‚‰ã«é«˜é€Ÿã«'))

= Summary: Other improvements\n(('note:ã¾ã¨ã‚:ä»–ã®æ”¹å–„ç‚¹'))

  * Enhanced invalid XML check.\n
    (('note:ç„¡åŠ¹XMLãƒã‚§ãƒƒã‚¯å¼·åŒ–'))
  * Unification of processing results for each REXML parser (DOM/SAX2/Pull/Stream).\n
    (('note:å„ãƒ‘ãƒ¼ã‚µãƒ¼é–“ã§ã®ãƒ‘ãƒ¼ã‚¹å‡¦ç†çµæœã®çµ±ä¸€'))


= Further work(1)\n(('note:ä»Šå¾Œã®æ”¹å–„æ¡ˆ(1)'))

  * Further optimization with new StringScanner features.\n(('note:StringScannerã®æ–°æ©Ÿèƒ½ã‚’ç”¨ã„ãŸã•ã‚‰ãªã‚‹æœ€é©åŒ–'))
    * Use StringScanner#scan_until(String) and StringScanner#peek_byte more.\n
      (('note:StringScanner#scan_until(String) ã‚„ StringScanner#peek_byte ã‚’ã‚ˆã‚Šä½¿ã£ã¦ã„ã'))

= Further work(2)\n(('note:ä»Šå¾Œã®æ”¹å–„æ¡ˆ(2)'))

    # img
    # src = images/rubykaigi-2019-p35-p78.png
    # relative_height = 50

  * (('tag:small'))Use StringScanner's new features in other gems.\n(('note:ä»–ã®gem ã§ã‚‚StringScannerã®æ–°æ©Ÿèƒ½ã‚’ä½¿ã†'))\n
    * (('tag:small'))Enhanced StringScanner may also make CSV faster.\n(('note:StringScannerã®å¼·åŒ–ã«ã‚ˆã‚Šã€CSVã‚‚ã‚ˆã‚Šé€Ÿãã§ãã‚‹ã‹ã‚‚ã—ã‚Œãªã„'))


== Slide properties

: enable-title-on-image
   false
